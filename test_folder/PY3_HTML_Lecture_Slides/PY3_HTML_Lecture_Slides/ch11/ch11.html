<!DOCTYPE html>
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta name="generator" content="HTML Tidy for Linux/x86 (vers 1st November 2003), see www.w3.org" />
    <title>Chapter 11, Python for Everyone, 2e</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="font-size-adjustment" content="-1" />
    <meta name="copyright"
          content="Copyright &#169; 2015 Wiley" />
    <link rel="stylesheet" href="styles/slidy.css" type="text/css" />
    <link rel="stylesheet" href="styles/horstmann.css" type="text/css" />
</head>
<body>
    <div class="background">
        <div class="slide ppLayoutCustom">
    <div><p class="title" >Chapter 11</p><br />
</div>
<div><p class="subtitle" ><span class="fontColorClass1">Recursion</span></p><br />
</div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Chapter Goals</p><br />
</div>
<div><ul><li>To learn to "think recursively"
</li><li>To be able to use recursive helper functions
</li><li>To understand the relationship between recursion and iteration
</li><li>To understand when the use of recursion affects the efficiency of an algorithm 
</li><li>To analyze problems that are much easier to solve by recursion than by iteration 
</li><li>To process data with recursive structures using mutual recursion
</li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Contents</p><br />
</div>
<div><ul><li>Triangle Numbers Revisited
</li><li>Problem Solving: Thinking Recursively
</li><li>Recursive Helper Functions
</li><li>The Efficiency of Recursion
</li><li>Permutations
</li><li>Backtracking
</li><li>Mutual Recursion
</li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >11.1 Triangle Numbers Revisited</p><br />
</div>
<div><ul><li>Triangle shape of side length 4:
<p class="object" ><span class="fontColorClass3">[] 
</span></p>
<p class="object" ><span class="fontColorClass3">[][] 
</span></p>
<p class="object" ><span class="fontColorClass3">[][][] 
</span></p>
<p class="object" ><span class="fontColorClass4">[][][][]
</span></p>
<ul></ul></li><li>Will use recursion to compute the area of a triangle of width <em>n</em> , assuming each <span class="fontColorClass4">[]</span> square has an area of 1
</li><li>Also called the <em>n<sup>th</sup> triangle number</em> 
</li><li>The third triangle number is 6, the fourth is 10 
</li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Handling Triangle of Width 1</p><br />
</div>
<div><ul><li>The triangle consists of a single square
</li><li>Its area is 1
</li><li>Take care of this case first:
</li></ul></div>
<div><pre>def triangleArea(sideLength) :
    if sideLength == 1 :
        return 1
    . . .
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Handling The General Case</p><br />
</div>
<div><ul><li> Assume we know the area of the smaller, colored triangle:
<p class="object" ><span class="fontColorClass3">[] 
</span></p>
<p class="object" ><span class="fontColorClass3">[][] 
</span></p>
<p class="object" ><span class="fontColorClass3">[][][] 
</span></p>
<p class="object" ><span class="fontColorClass4">[][][][]
</span></p>
<ul></ul></li><li> Area of larger triangle can be calculated as 
</li></ul></div>
<div><pre>area = smallerArea + sideLength
</pre></div>
<div><ul><li class=""> To get the area of the smaller triangle
<ul><li class="">Call the <code>triangleArea()</code> function:
</li></ul></li></ul></div>
<div><pre>smallerSideLength = sideLength - 1
smallerArea = triangleArea(smallerSideLength)
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Computing the Area of a Triangle With Width 4</p><br />
</div>
<div><ul><li><code>triangleArea()</code> function makes a smaller triangle of width 3 
</li><li>It calls <code>triangleArea()</code> on that triangle 
<ul><li>That function makes a smaller triangle of width 2 
</li><li>It calls <code>triangleArea()</code> on that triangle 
<ul><li>That function makes a smaller triangle of width 1 
</li><li>It calls <code>triangleArea()</code> on that triangle 
<ul><li>That function returns 1 
</li></ul></li><li>The function returns <code>smallerArea + sideLength</code> = 1 + 2 = 3 
</li></ul></li><li>The function returns <code>smallerArea + sideLength </code>= 3 + 3 = 6 
</li></ul></li><li>The function returns <code>smallerArea + sideLength </code>= 6 + 4 = 10 
</li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Recursive Computation</p><br />
</div>
<div><ul><li>A <strong>recursive computation</strong> solves a problem by using the solution to the same problem with simpler inputs
</li><li>Call pattern of a <strong>recursive function</strong> is complicated
<ul><li>Key: <em>Don't think about it
</em></li></ul></li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Successful Recursion</p><br />
</div>
<div><ul><li> Every recursive call must simplify the computation in some way 
</li><li> There must be special cases to handle the simplest computations directly 
</li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Other Ways to Compute Triangle Numbers</p><br />
</div>
<div><ul><li>The area of a triangle equals the sum:
<pre>1 + 2 + 3 + ... + sideLength 
</pre>
<ul></ul></li><li>Using a simple loop: 
<pre>area = 0; 
for i in range (1, (sideLength+1), 1) :   
   area = area + i 
</pre>
<ul></ul></li><li>Using math: 
<p class="object" > 1 + 2 + ... + <em>n </em>= <em>n </em>× (<em>n</em> + 1)/2  
</p><p>=&gt; <code>n * (n + 1) / 2
</code></p>
</li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >trianglenumbers.py</p><br />
</div>
<div><pre>##
#  This program computes a triangle number using recursion.
#

def main() :
   area = triangleArea(10)      
   print("Area:", area)
   print("Expected: 55")

## Computes the area of a triangle with a given side length.
#  @param sideLength the side length of the triangle base
#  @return the area
#
def triangleArea(sideLength) :
   if sideLength <= 0 :
      return 0
   if sideLength == 1 :
      return 1
   smallerSideLength = sideLength - 1
   smallerArea = triangleArea(smallerSideLength)
   area = smallerArea + sideLength
   return area
         
# Start the program.
main()
</pre></div>
<div><p>Program Run
</p><pre>
Area: 55
Expected: 55
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Special Topic 11.1</p><br />
</div>
<div><ul><li>An Object-Oriented version of the triangles program:
</li></ul></div>
<div><pre>class Triangle
    def _ _init_ _ (self, sideLength) :
        self._sideLength = sideLength
    def getArea(self) :
        if self._sideLength == 1 :
            return 1
        . . .
</pre></div>
<div><ul><li>General case:  Compute the area of the larger triangle as <code>smallerArea + self._sideLength
</code></li><li>To get the smaller area:
</li></ul></div>
<div><pre>smallerTriangle = Triangle(self._sideLength - 1)
smallerArea = smallerTriangle.getArea()
area = smallerArea + self._sideLength
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Common Error 11.1</p><br />
</div>
<div><ul><li>Infinite recursion: 
<ul><li>A function calling itself over and over with no end in sight
</li><li>The computer needs some amount of memory for bookkeeping during each call
</li><li>After some number of calls, all memory that is available for this purpose is exhausted
</li><li>Your program shuts down and reports a "stack overflow"
</li></ul></li><li>Causes:
<ul><li>The arguments don't get simpler or because a special terminating case is missing
</li></ul></li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Thinking Recursively</p><br />
</div>
<div><ul><li> Problem: Test whether a sentence is a palindrome
</li><li><strong> Palindrome:</strong> A string that is equal to itself when you reverse all characters
<ul><li><em>A man, a plan, a canal – Panama! 
</em></li><li><em>Go hang a salami, I'm a lasagna hog 
</em></li><li><em>Madam, I'm Adam
</em></li></ul></li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Implement <code>isPalindrome()</code> Function</p><br />
</div>
<div><pre>## Tests whether a string is a palindrome.
# @param text a string that is being checked
# @return True if text is a palindrome, False otherwise
#
def isPalindrome(text) :
    . . .
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Thinking Recursively: Step 1</p><br />
</div>
<div><ul><li>Consider various ways to simplify inputs
</li><li>Several possibilities:
<ul><li><em>Remove the first character
</em></li><li><em>Remove the last character 
</em></li><li><em>Remove both the first and last characters
</em></li><li><em>Remove a character from the middle 
</em></li><li><em>Cut the string into two halves
</em></li></ul></li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Thinking Recursively: Step 2 (1)</p><br />
</div>
<div><ul><li>Combine solutions with simpler inputs into a solution of the original problem
</li><li>Most promising simplification: <em>Remove both first and last characters
</em><ul><li><em>"adam, I'm Ada" is a palindrome too!
</em></li></ul></li><li>Thus, a word is a palindrome if 
<ul><li><em>The first and last letters match, and
</em></li><li><em>Word obtained by removing the first and last letters is a palindrome
</em></li></ul></li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Thinking Recursively: Step 2 (2)</p><br />
</div>
<div><ul><li>What if first or last character is not a letter? Ignore it
<ul><li><em>If the first and last characters are letters, check whether they match; if so, remove both and test shorter string 
</em></li><li><em>If last character isn't a letter, remove it and test shorter string 
</em></li><li><em>If first character isn't a letter, remove it and test shorter string 
</em></li></ul></li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Thinking Recursively: Step 3</p><br />
</div>
<div><ul><li><em> </em>Find solutions to the simplest inputs
<ul><li>Strings with two characters
<ul><li><em>No special case required; step two still applies 
</em></li></ul></li><li>Strings with a single character 
<ul><li><em>They are palindromes
</em></li></ul></li><li>The empty string 
<ul><li><em>It is a palindrome 
</em></li></ul></li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Thinking Recursively: Step 4 (1)</p><br />
</div>
<div><ul><li>Implement the solution by combining the simple cases and the reduction step
</li></ul></div>
<div><pre>def isPalindrome(text) :
    length = len(text)
    # Separate case for shortest strings.
    if length &lt;= 1 :
        return True
    else :
        # Get first and last characters, converted to    
        # lowercase.
        first = text[0].lower()
        last = text[length - 1].lower()
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Thinking Recursively: Step 4 (2)</p><br />
</div>
<div><pre>        # Non base case
        if first.isalpha() and last.isalpha() :
            # Both are letters.
            if first == last :
                # Remove both first and last character.
                shorter = text[1 : length - 1]
                return isPalindrome(shorter)
            else :
                return False
        elif not last.isalpha() :
            # Remove last character.
            shorter = text[0 : length - 1]
            return isPalindrome(shorter)
        else :
            # Remove first character.
            shorter = text[1 : length]
            return isPalindrome(shorter)
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Recursive Helper Functions</p><br />
</div>
<div><ul><li>Sometimes it is easier to find a recursive solution if you make a slight change to the original problem
</li><li>Consider the palindrome test of previous section
</li><li>It is a bit inefficient to construct new string objects in every step
</li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Substring Palindromes (1)</p><br />
</div>
<div><ul><li>Rather than testing whether the sentence is a palindrome, check whether a substring is a palindrome: 
</li></ul></div>
<div><pre>## Recursively tests whether a substring is
# a palindrome.
# @param text a string that is being checked
# @param start the index of the first character of the substring
# @param end the index of the last character of the substring
# @return True if the substring is a palindrome
#
def substringIsPalindrome(text, start, end) :
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Substring Palindromes (2)</p><br />
</div>
<div><ul><li>Then, simply call the helper function with positions that test the entire string: 
</li></ul></div>
<div><pre>def isPalindrome(text) :
    return substringIsPalindrome(text, 0, len(text) – 1)
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Recursive Helper Function</p><br />
</div>
<div><pre>def substringIsPalindrome(text, start, end) :
    # Separate case for substrings of length 0 and 1.
    if start &gt;= end :
        return True
    else :
    # Get first and last characters, converted to lowercase.
        first = text[start].lower()
        last = text[end].lower()
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Recursive Helper Function</p><br />
</div>
<div><pre>    if first.isalpha() and last.isalpha() :
        if first == last :
            # Test substring that doesn't contain the matching 
            # letters.
            return substringIsPalindrome
               (text, start + 1, end - 1)
        else :
            return False
    elif not last.isalpha() :
        # Test substring that doesn't contain the last character.
        return substringIsPalindrome(text, start, end - 1)
    else :
        # Test substring that doesn't contain the first 
        # character. 
        return substringIsPalindrome(text, start + 1, end)
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >11.4 The Efficiency of Recursion</p><br />
</div>
<div><ul><li> Fibonacci sequence: Sequence of numbers defined by
<p class="object" ><em>f</em><sub>1</sub> = 1
</p><p><em>f</em><sub>2</sub> = 1
</p><p><em>f</em><sub><em>n</em></sub> = <em>f</em><sub><em>n</em>-1</sub> + <em>f</em><sub><em>n</em>-2
</sub></p>
<p class="object" >
</p>
<ul></ul></li><li> First ten terms:
<p class="object" > 1, 1, 2, 3, 5, 8, 13, 21, 34, 55
</p></li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >recursivefib.py</p><br />
</div>
<div><pre>##
#  This program computes Fibonacci numbers using a recursive function.
#

def main() :
   n = int(input("Enter n: "))
   for i in range(1, n + 1) :
      f = fib(i)
      print("fib(%d) = %d" % (i, f))

## Computes a Fibonacci number.
#  @param n an integer
#  @return the nth Fibonacci number
#
def fib(n) :
   if n <= 2 :
      return 1
   else :
      return fib(n - 1) + fib(n - 2)
      
# Start the program.
main()
</pre></div>
<div><p>Program Run
</p><pre>Enter n: 50
fib(1) = 1
fib(2) = 1
fib(3) = 2
fib(4) = 3
fib(5) = 5
. . .
fib(50) = 12586269025
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Efficiency of Recursion</p><br />
</div>
<div><ul><li> Recursive implementation of <code>fib()</code> is straightforward
</li><li> Watch the output closely as you run the test program
</li><li> First few calls to <code>fib()</code> are quite fast
</li><li> For larger values, the program pauses an amazingly long time between outputs 
</li><li> To find out the problem, let's insert <strong>trace messages
</strong></li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >recursivefibtracer.py (1)</p><br />
</div>
<div><pre>##
#  This program prints trace messages that show how often the
#  recursive function for computing Fibonacci numbers calls itself.
#

def main() :
   n = int(input("Enter n: "))
   for i in range(1, n + 1) :
      f = fib(i)
      print("fib(%d) = %d" % (i, f))

## Computes a Fibonacci number.
#  @param n an integer
#  @return the nth Fibonacci number
#
def fib(n) :
   print("Entering fib: n =", n) 
   if n <= 2 :
      f = 1
   else :
      f = fib(n - 1) + fib(n - 2)
   print("Exiting fib: n =", n, "return value =", f)
   return f
      
# Start the program.
main()
</pre></div>



</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >recursivefibtracer.py (2)</p><br />
</div>
<div><p>Program Run</p></div>
<div><pre>Enter n: 6
Entering fib: n = 6
Entering fib: n = 5
Entering fib: n = 4
Entering fib: n = 3
Entering fib: n = 2
Exiting fib: n = 2 return value = 1
Entering fib: n = 1
Exiting fib: n = 1 return value = 1
Exiting fib: n = 3 return value = 2
Entering fib: n = 2
Exiting fib: n = 2 return value = 1
Exiting fib: n = 4 return value = 3
Entering fib: n = 3
Entering fib: n = 2
Exiting fib: n = 2 return value = 1
Entering fib: n = 1
Exiting fib: n = 1 return value = 1
Exiting fib: n = 3 return value = 2
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Call Pattern of Recursive <code>fib()</code> Function</p><br />
</div>
<div><img src='images/slide32-Picture1.png' /></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Efficiency of Recursion</p><br />
</div>
<div><ul><li>The function takes so long because it computes the same values over and over
</li><li>Computation of <code>fib(6)</code> calls <code>fib(3)</code> three times
</li><li>Imitate the pencil-and-paper process to avoid computing the values more than once
</li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Efficiency of Recursion</p><br />
</div>
<div><ul><li> Occasionally, a recursive solution runs much slower than its iterative counterpart
</li><li> In most cases, the recursive solution is only slightly slower
</li><li> The iterative <code>isPalindrome()</code> performs only slightly better than recursive solution
<ul><li><em>Each recursive function call takes a certain amount of processor time
</em></li></ul></li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >loopfib.py (1)</p><br />
</div>
<div><pre>##
#  This program computes Fibonacci numbers using an iterative function.
#

def main() :
   n = int(input("Enter n: "))
   for i in range(1, n + 1) :
      f = fib(i)
      print("fib(%d) = %d" % (i, f))

## Computes a Fibonacci number.
#  @param n an integer
#  @return the nth Fibonacci number
#
def fib(n) :
   if n <= 2 :
      return 1
   else :
      olderValue = 1
      oldValue = 1
      newValue = 1
      for i in range(3, n + 1) :
         newValue = oldValue + olderValue
         olderValue = oldValue
         oldValue = newValue
         
      return newValue
      
# Start the program.
main()
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >loopfib.py (2)</p><br />
</div>
<div></div>
<div><p>Program Run
<p><pre>Enter n: 50
fib(1) = 1
fib(2) = 1
fib(3) = 2
fib(4) = 3
fib(5) = 5
fib(6) = 8
fib(7) = 13
. . .
fib(50) = 12586269025
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Efficiency of Recursion</p><br />
</div>
<div><ul><li>Smart compilers can avoid recursive function calls if they follow simple patterns
</li><li>Most compilers don't do that  
</li><li>In many cases, a recursive solution is easier to understand and implement correctly than an iterative solution 
</li><li> '<em>To iterate is human, to recurse divine.</em>' 	- L. Peter Deutsch 
</li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Iterative <code>isPalindrome()</code> Function</p><br />
</div>
<div><pre>def isPalindrome(text) :
    start = 0
    end = len(text) - 1
    while start < end :
        first = text[start].lower()
        last = text[end].lower()
        if first.isalpha() and last.isalpha() :
            # Both are letters.
            if first == last :
                start = start + 1
                end = end - 1
            else :
                return False
        if not last.isalpha() 
            end = end - 1
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >11.5 Permutations</p><br />
</div>
<div><ul><li>Design a class that will list all permutations of string, where a permutation is a rearrangement of the letters 
</li><li>The string "eat" has six permutations:
<ul><li>"eat"
</li><li>"eta" 
</li><li>"aet"
</li><li>"ate"
</li><li>"tea"
</li><li>"tae"
</li></ul></li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Generate All Permutations (1)</p><br />
</div>
<div><ul><li> Generate all permutations that start with 'e', then 'a', then 't' 
</li><li> The string "eat" has six permutations:
<ul><li>"eat"
</li><li>"eta" 
</li><li>"aet"
</li><li>"ate"
</li><li>"tea"
</li><li>"tae"
</li></ul></li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Generate All Permutations (2)</p><br />
</div>
<div><ul><li>Generate all permutations that start with <span class="fontColorClass6">'e'</span>, then <span class="fontColorClass6">'a'</span>, then <span class="fontColorClass6">'t'</span><span class="fontColorClass4"> 
</span></li><li>To generate permutations starting with <span class="fontColorClass6">'e'</span>, we need to find all permutations of <span class="fontColorClass6">'at' 
</span></li><li>This is the same problem with simpler inputs 
</li><li>Use recursion 
</li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Implementing <code>permutations()</code> Function</p><br />
</div>
<div><ul><li> Loop through all positions in the word to be permuted
</li><li> For each of them, compute the shorter word obtained by removing the i<sup>th</sup> letter:
</li></ul></div>
<div><pre>shorter = word[ : i] + word[i + 1 : ]
</pre></div>
<div><ul><li class="">Compute the permutations of the shorter word:
</li></ul></div>
<div><pre>shorterPermutations = permutations(shorter)
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Implementing <code>permutations()</code> Function</p><br />
</div>
<div><ul><li> Add the removed letter to the front of all permutations of the shorter word:
</li></ul></div>
<div><pre>for s in shorterPermutations :
    result.append(word[i] + s)
</pre></div>
<div><ul><li class="">Special case for the simplest string, the empty string, which has a single permutation - itself
</li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >permutations.py (1)</p><br />
</div>
<div><pre>##
#  This program computes permutations of a string.
#
def main() :
   for string in permutations("eat") :
      print(string)

## Gets all permutations of a given word.
#  @param word the string to permute
#  @return a list of all permutations
def permutations(word) :
   result = []

   # The empty string has a single permutation: itself.
   if len(word) == 0 :
      result.append(word)
      return result
   else :
      # Loop through all character positions.
      for i in range(len(word)) :
         # Form a shorter word by removing the ith character.
         shorter = word[ : i] + word[i + 1 :]

         # Generate all permutations of the simpler word.
         shorterPermutations = permutations(shorter)

         # Add the removed character to the front of each permutation 
         # of the simpler word. 
         for string in shorterPermutations :
            result.append(word[i] + string)

      # Return all permutations.
      return result

# Start the program.
main()
</pre></div>





</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >permutations.py (2)</p><br />
</div>
<div><p>Program Run
</p></div>
<div><pre>
eat
eta
aet
ate
tea
tae
</pre></div>



</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Backtracking</p><br />
</div>
<div><ul><li>Backtracking examines partial solutions, abandoning unsuitable ones and returning to consider other candidates
</li><li>Can be used to
<ul><li>solve crossword puzzles
</li><li>escape from mazes
</li><li>find solutions to systems that are constrained by rules
</li></ul></li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Backtracking Characteristic Properties</p><br />
</div>
<div><ul><li class="decimal">A procedure to examine a partial solution and determine whether to:
<ul><li class="upper-roman">accept it as an actual solution or,
</li><li class="upper-roman">abandon it (because it either violates some rules or can never lead to a valid solution)
</li></ul></li><li class="decimal">A procedure to extend a partial solution, generating one or more solutions that come closer to the goal</li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Recursive Backtracking Algorithm</p><br />
</div>
<div><pre class="pseudo">Solve(partialSolution)
     Examine(partialSolution).
     If accepted
          Add partialSolution to the list of solutions.
     Else if not abandoned
          For each p in extend(partialSolution)
              Solve(p)
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Eight Queens Problem</p><br />
</div>
<div><ul><li><strong> Problem: </strong>position eight queens on a chess board so that none of them attacks another according to the rules of chess
</li><li> A solution:
</li></ul></div>
<div><img src='images/slide49-Picture5.png' /></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Eight Queens Problem</p><br />
</div>
<div><ul><li> Easy to examine a partial solution:
<ul><li>If two queens attack one another, reject it
</li><li>Otherwise, if it has eight queens, accept it
</li><li>Otherwise, continue
</li></ul></li><li> Easy to extend a partial solution:
<ul><li>Add another queen on an empty square
</li></ul></li><li> Systematic extensions:
<ul><li>Place first queen on row 1
</li><li>Place the next on row 2
</li><li>Etc.
</li></ul></li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Function: <code>examine()</code></p><br />
</div>
<div><pre>def examine(partialSolution) :
    for i in range(0, len(partialSolution)) :
        for j in range(i + 1, len(partialSolution)) :
            if attacks(partialSolution[i], 
               partialSolution[j]) :
                return ABANDON
    if len(partialSolution) == NQUEENS :
        return ACCEPT
    else :
        return CONTINUE
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Function: <code>extend()</code></p><br />
</div>
<div><pre>def extend(partialSolution) :
    results = []
    row = len(partialSolution) + 1
    for column in "abcdefgh" :
        newSolution = list(partialSolution)
        newSolution.append(column + str(row))
        results.append(newSolution)
    return results
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Diagonal Attack</p><br />
</div>
<div><ul><li>To determine whether two queens attack each other diagonally:
<ul><li>Check whether slope is ±1
</li></ul><pre>(row2 – row1)/(column2 – column1) = ±1
 row2 – row1 = ±(column2 – column1)
 row2 – row1| = |column2 – column1|  
</pre></li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Backtracking in the Four Queens Problem (1)</p><br />
</div>
<div><img src='images/slide54-Picture2.png' /></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Backtracking in the Four Queens Problem (2)</p><br />
</div>
<div><ul><li> Starting with a blank board, four partial solutions with a queen in row 1 
</li><li> When the queen is in column 1, four partial solutions with a queen in row 2
<ul><li>Two are abandoned immediately
</li><li>Other two lead to partial solutions with three queens&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;and&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;, all but one of which are abandoned
</li></ul></li><li> One partial solution is extended to four queens, but all of those are abandoned as well 
</li></ul></div>
<div style="position:absolute;top:8.3%;left:83%;"><img src='images/slide55-Picture5.png' /></div>
<div style="position:absolute;top:12.3%;left:88%;"><img src='images/slide55-Picture6.png' /></div>
<div style="position:absolute;top:21.3%;left:64.1%;"><img src='images/slide55-Picture7.png' /></div>
<div style="position:absolute;top:21.3%;left:72.1%;"><img src='images/slide55-Picture8.png' /></div>
<div style="position:absolute;top:32.5%;left:10.7%;"><img src='images/slide55-Picture9.png' /></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >queens.py (1)</p><br />
</div>
<div><pre>##
#  This program solves the eight queens problem using backtracking.
#

def main() :
   solve([])

COLUMNS = "abcdefgh"
NQUEENS = len(COLUMNS)
ACCEPT = 1
CONTINUE = 2
ABANDON = 3

## Prints all solutions to the problem that can be extended from 
#  a given partial solution.
#  @param partialSolution the partial solution
#
def solve(partialSolution) :
   exam = examine(partialSolution)
   if exam == ACCEPT :
      print(partialSolution)
   elif exam != ABANDON :
      for p in extend(partialSolution) :
         solve(p)
</pre></div>
<div><pre># Start the program.
main()
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >queens.py (2)</p><br />
</div>
<div><pre>## Examines a partial solution.
#  @param partialSolution the partial solution
#  @return ACCEPT if it is a complete solution, ABANDON if it is invalid,
#  or CONTINUE otherwise
def examine(partialSolution) :   
   for i in range(0, len(partialSolution)) :
      for j in range(i + 1, len(partialSolution)) :
         if attacks(partialSolution[i], partialSolution[j]) :
            return ABANDON
   if len(partialSolution) == NQUEENS :
      return ACCEPT
   else :
      return CONTINUE

## Checks whether one position attacks another. Positions are given as
#  strings with a letter for the column and a number for the row.
#  @param p1 a position
#  @param p2 another position
#  @return True if the positions are in the same row, column, or diagonal
def attacks(p1, p2) :
   column1 = COLUMNS.index(p1[0]) + 1
   row1 = int(p1[1])
   column2 = COLUMNS.index(p2[0]) + 1
   row2 = int(p2[1])
   return (row1 == row2 or column1 == column2 or 
      abs(row1 - row2) == abs(column1 - column2))

## Extends a partial solution to the next column.
#  @param partialSolution a partial solution to the problem
#  @return a list of all partial solutions that have a queen added in the
#  next column
def extend(partialSolution) :
   results = []
   row = len(partialSolution) + 1
   for column in COLUMNS :
      newSolution = list(partialSolution)
      newSolution.append(column + str(row))
      results.append(newSolution)
   return results
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >queens.py (3)</p><br />
</div>
<div><img src='images/slide58-Picture2.png' /></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >11.7 Mutual Recursion</p><br />
</div>
<div><ul><li><strong> Problem:</strong> Compute the value of arithmetic expressions such as:
<span class="fontColorClass6"><p class="object" > 3 + 4 * 5 
</p><p> (3 + 4) * 5 
</p><p> 1 - (2 - (3 - (4 - 5)))
</p></span>
<ul></ul></li><li> Computing the expression is complicated
<ul><li><span class="fontColorClass6">*</span> and <span class="fontColorClass6">/</span> bind more strongly than <span class="fontColorClass6">+</span> and <span class="fontColorClass6">–
</span></li><li>Parentheses can be used to group sub-expressions
</li></ul></li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Syntax Diagrams for Evaluating an Expression</p><br />
</div>
<div><img src='images/slide60-Picture6.png' /></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Mutual Recursion</p><br />
</div>
<div><ul><li>An <em>expression</em> can be broken down into a sequence of terms, separated by <span class="fontColorClass6">+</span> or <span class="fontColorClass6">–</span> 
</li><li>Each <em>term</em> is broken down into a sequence of factors, separated by <span class="fontColorClass6">*</span> or <span class="fontColorClass6">/
</span></li><li>Each <em>factor</em> is either a parenthesized expression or a number 
</li><li>The syntax trees represent which operations should be carried out first 
</li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Syntax Trees for Two Expressions</p><br />
</div>
<div><img src='images/slide62-Picture7.png' /></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Mutual Recursion</p><br />
</div>
<div><ul><li>In a mutual recursion, a set of cooperating functions calls each other repeatedly 
</li><li>To compute the value of an expression, implement 3 functions that call each other recursively: 
<ul><li><code>expression()
</code></li><li><code>term()
</code></li><li><code>factor()
</code></li></ul></li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Function: <code>expression()</code></p><br />
</div>
<div><pre>def expression(tokens) :
    value = term(tokens)
    done = False
    while not done and len(tokens) &gt; 0 :
        next = tokens[0]
        if next == "+" or next == "-" :
            tokens.pop(0)   # Discard "+" or "-"
            value2 = term(tokens)
            if next == "+" :
                value = value + value2
            else :
                value = value - value2
        else :
            done = True

return value
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Function: <code>term()</code></p><br />
</div>
<div><ul><li>The <code>term()</code> function calls <code>factor()</code> in the same way, multiplying or dividing the factor values
</li></ul></div>
<div><pre>def term(tokens) :
    value = factor(tokens)
    done = False
    while not done and len(tokens) &gt; 0:
        next = tokens[0]
        if next == "*" or next == "/" :
            tokens.pop(0)
            value2 = factor(tokens)
            if next == "*" :
                value = value * value2
            else :
                value = value / value2
       else :
           done = True

return value
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Function: <code>factor()</code></p><br />
</div>
<div><pre>def factor(tokens) :
    next = tokens.pop(0)
    if next == "(" :
        value = expression(tokens)
        tokens.pop(0)   # Discard ")"
    else :
        value = next

    return value
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Trace <code>(3 + 4) * 5</code></p><br />
</div>
<div><p>To see the mutual recursion clearly, trace through the expression <code>(3+4)*5</code>: 
</p><ul><li><code>expression()</code> calls <code>term()
</code><ul><li><code>term()</code> calls <code>factor()
</code><ul><li><code>factor()</code> consumes the <span class="fontColorClass6">(</span> input 
</li><li><code>factor()</code> calls <code>expression() 
</code><ul><li><code>expression()</code> returns eventually with the value of 7, having consumed 3 + 4. This is the recursive call. 
</li></ul><li><code>factor()</code> consumes the <span class="fontColorClass6">)</span> input
</li><li><code>factor()</code> returns 7 
</li></ul><li><code>term()</code> consumes the inputs <span class="fontColorClass6">*</span> and 5 and returns 35 
</li></ul><li><code>expression()</code> returns 35 
</li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >evaluator.py (1)</p><br />
</div>
<div><pre>## 
#  This program evaluates arithmetic expressions.
#

def main() :
   expr = input("Enter an expression: ")
   tokens = tokenize(expr)
   value = expression(tokens)
   print(expr + "=" + str(value))

## Breaks a string into tokens.
#  @param inputLine a string consisting of digits and symbols
#  @return a list of numbers (made from the digits of the input) and symbols
#
def tokenize(inputLine) :
   result = []
   i = 0
   while i < len(inputLine) :
      if inputLine[i].isdigit() :
         j = i + 1
         while j < len(inputLine) and inputLine[j].isdigit() :
            j = j + 1
         result.append(int(inputLine[i : j]))
         i = j
      else :
         result.append(inputLine[i])
         i = i + 1
   return result
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >evaluator.py (2)</p><br />
</div>
<div><pre>## Evaluates the expression.
#  @param tokens the list of tokens to process
#  @return the value of the expression
#
def expression(tokens) :
   value = term(tokens)
   done = False
   while not done and len(tokens) > 0 :
      next = tokens[0]
      if next == "+" or next == "-" :
         tokens.pop(0)  # Discard "+" or "-"
         value2 = term(tokens)
         if next == "+" : 
            value = value + value2 
         else :
            value = value - value2
      else : 
         done = True
         
   return value
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >evaluator.py (3)</p><br />
</div>
<div><pre>## Evaluates the next term found in the expression.
#  @param tokens the list of tokens to process
#  @return the value of the term
#
def term(tokens) :
   value = factor(tokens)
   done = False
   while not done and len(tokens) > 0 :
      next = tokens[0]
      if next == "*" or next == "/" :
         tokens.pop(0)
         value2 = factor(tokens)
         if next == "*" :
            value = value * value2               
         else : 
            value = value / value2
      else : 
         done = True         
   
   return value
</pre></div>

   


</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >evaluator.py (4)</p><br />
</div>
<div><pre>## Evaluates the next factor found in the expression.
#  @param tokens the list of tokens to process
#  @return the value of the factor
#
def factor(tokens) :
   next = tokens.pop(0)
   if next == "(" :
      value = expression(tokens)
      tokens.pop(0)  # Discard ")"
   else :
      value = next
      
   return value

# Start the program.
main()
</pre></div>
<div><p>Program Run
</p><pre>Enter an expression: 3+4*5
3+4*5=23
</pre></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Summary</p><br />
</div>
<div><ul><li>Understand the control flow in a recursive computation
<ul><li>A recursive computation solves a problem by using the solution to the same problem with simpler inputs
</li><li>For a recursion to terminate, there must be special cases for the simplest values
</li></ul></li><li>Design a recursive solution to a problem
</li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Summary</p><br />
</div>
<div><ul><li>Identify recursive helper functions for solving a problem
<ul><li>Sometimes it is easier to find a recursive solution if you make a slight change to the original problem
</li></ul></li><li>Contrast the efficiency of recursive and non-recursive algorithms
<ul><li>Occasionally, a recursive solution runs much slower than its iterative counterpart. However, in most cases, the recursive solution is only slightly slower
</li><li>In many cases, a recursive solution is easier to understand and implement correctly than an iterative solution
</li></ul></li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Summary</p><br />
</div>
<div><ul><li>Review a complex recursion example that cannot be solved with a simple loop
<ul><li>The permutations of a string can be obtained more naturally through recursion than with a loop
</li></ul></li><li>Use backtracking to solve problems that require trying out multiple paths
<ul><li>Backtracking examines partial solutions, abandoning unsuitable ones and returning to consider other candidates
</li></ul></li></ul></div>




</div>
<div class="slide ppLayoutObject">
    <div><p class="title" >Summary</p><br />
</div>
<div><ul><li>Recognize the phenomenon of mutual recursion in an expression evaluator
<ul><li>In a mutual recursion, cooperating functions or methods call each other repeatedly
</li></ul></li></ul></div>




</div>

    </div>
    <script src="scripts/jquery-2.1.4.min.js" charset="utf-8" type="text/javascript"></script>
    <script src="scripts/slidy.js" charset="utf-8" type="text/javascript"></script>
    
</body>
</html>